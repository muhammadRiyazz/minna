// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'operators_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

/// @nodoc
mixin _$OperatorsEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getop,
    required TResult Function() getDTHop,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getop,
    TResult? Function()? getDTHop,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getop,
    TResult Function()? getDTHop,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Getop value) getop,
    required TResult Function(GetDTHop value) getDTHop,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Getop value)? getop,
    TResult? Function(GetDTHop value)? getDTHop,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Getop value)? getop,
    TResult Function(GetDTHop value)? getDTHop,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OperatorsEventCopyWith<$Res> {
  factory $OperatorsEventCopyWith(
    OperatorsEvent value,
    $Res Function(OperatorsEvent) then,
  ) = _$OperatorsEventCopyWithImpl<$Res, OperatorsEvent>;
}

/// @nodoc
class _$OperatorsEventCopyWithImpl<$Res, $Val extends OperatorsEvent>
    implements $OperatorsEventCopyWith<$Res> {
  _$OperatorsEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of OperatorsEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$GetopImplCopyWith<$Res> {
  factory _$$GetopImplCopyWith(
    _$GetopImpl value,
    $Res Function(_$GetopImpl) then,
  ) = __$$GetopImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GetopImplCopyWithImpl<$Res>
    extends _$OperatorsEventCopyWithImpl<$Res, _$GetopImpl>
    implements _$$GetopImplCopyWith<$Res> {
  __$$GetopImplCopyWithImpl(
    _$GetopImpl _value,
    $Res Function(_$GetopImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of OperatorsEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$GetopImpl implements Getop {
  const _$GetopImpl();

  @override
  String toString() {
    return 'OperatorsEvent.getop()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$GetopImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getop,
    required TResult Function() getDTHop,
  }) {
    return getop();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getop,
    TResult? Function()? getDTHop,
  }) {
    return getop?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getop,
    TResult Function()? getDTHop,
    required TResult orElse(),
  }) {
    if (getop != null) {
      return getop();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Getop value) getop,
    required TResult Function(GetDTHop value) getDTHop,
  }) {
    return getop(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Getop value)? getop,
    TResult? Function(GetDTHop value)? getDTHop,
  }) {
    return getop?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Getop value)? getop,
    TResult Function(GetDTHop value)? getDTHop,
    required TResult orElse(),
  }) {
    if (getop != null) {
      return getop(this);
    }
    return orElse();
  }
}

abstract class Getop implements OperatorsEvent {
  const factory Getop() = _$GetopImpl;
}

/// @nodoc
abstract class _$$GetDTHopImplCopyWith<$Res> {
  factory _$$GetDTHopImplCopyWith(
    _$GetDTHopImpl value,
    $Res Function(_$GetDTHopImpl) then,
  ) = __$$GetDTHopImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GetDTHopImplCopyWithImpl<$Res>
    extends _$OperatorsEventCopyWithImpl<$Res, _$GetDTHopImpl>
    implements _$$GetDTHopImplCopyWith<$Res> {
  __$$GetDTHopImplCopyWithImpl(
    _$GetDTHopImpl _value,
    $Res Function(_$GetDTHopImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of OperatorsEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$GetDTHopImpl implements GetDTHop {
  const _$GetDTHopImpl();

  @override
  String toString() {
    return 'OperatorsEvent.getDTHop()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$GetDTHopImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getop,
    required TResult Function() getDTHop,
  }) {
    return getDTHop();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getop,
    TResult? Function()? getDTHop,
  }) {
    return getDTHop?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getop,
    TResult Function()? getDTHop,
    required TResult orElse(),
  }) {
    if (getDTHop != null) {
      return getDTHop();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Getop value) getop,
    required TResult Function(GetDTHop value) getDTHop,
  }) {
    return getDTHop(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Getop value)? getop,
    TResult? Function(GetDTHop value)? getDTHop,
  }) {
    return getDTHop?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Getop value)? getop,
    TResult Function(GetDTHop value)? getDTHop,
    required TResult orElse(),
  }) {
    if (getDTHop != null) {
      return getDTHop(this);
    }
    return orElse();
  }
}

abstract class GetDTHop implements OperatorsEvent {
  const factory GetDTHop() = _$GetDTHopImpl;
}

/// @nodoc
mixin _$OperatorsState {
  bool get isLoading => throw _privateConstructorUsedError;
  List<String>? get opList => throw _privateConstructorUsedError;
  List<String>? get opDTHList => throw _privateConstructorUsedError;

  /// Create a copy of OperatorsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $OperatorsStateCopyWith<OperatorsState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OperatorsStateCopyWith<$Res> {
  factory $OperatorsStateCopyWith(
    OperatorsState value,
    $Res Function(OperatorsState) then,
  ) = _$OperatorsStateCopyWithImpl<$Res, OperatorsState>;
  @useResult
  $Res call({bool isLoading, List<String>? opList, List<String>? opDTHList});
}

/// @nodoc
class _$OperatorsStateCopyWithImpl<$Res, $Val extends OperatorsState>
    implements $OperatorsStateCopyWith<$Res> {
  _$OperatorsStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of OperatorsState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isLoading = null,
    Object? opList = freezed,
    Object? opDTHList = freezed,
  }) {
    return _then(
      _value.copyWith(
            isLoading: null == isLoading
                ? _value.isLoading
                : isLoading // ignore: cast_nullable_to_non_nullable
                      as bool,
            opList: freezed == opList
                ? _value.opList
                : opList // ignore: cast_nullable_to_non_nullable
                      as List<String>?,
            opDTHList: freezed == opDTHList
                ? _value.opDTHList
                : opDTHList // ignore: cast_nullable_to_non_nullable
                      as List<String>?,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$OperatorsStateImplCopyWith<$Res>
    implements $OperatorsStateCopyWith<$Res> {
  factory _$$OperatorsStateImplCopyWith(
    _$OperatorsStateImpl value,
    $Res Function(_$OperatorsStateImpl) then,
  ) = __$$OperatorsStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool isLoading, List<String>? opList, List<String>? opDTHList});
}

/// @nodoc
class __$$OperatorsStateImplCopyWithImpl<$Res>
    extends _$OperatorsStateCopyWithImpl<$Res, _$OperatorsStateImpl>
    implements _$$OperatorsStateImplCopyWith<$Res> {
  __$$OperatorsStateImplCopyWithImpl(
    _$OperatorsStateImpl _value,
    $Res Function(_$OperatorsStateImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of OperatorsState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isLoading = null,
    Object? opList = freezed,
    Object? opDTHList = freezed,
  }) {
    return _then(
      _$OperatorsStateImpl(
        isLoading: null == isLoading
            ? _value.isLoading
            : isLoading // ignore: cast_nullable_to_non_nullable
                  as bool,
        opList: freezed == opList
            ? _value._opList
            : opList // ignore: cast_nullable_to_non_nullable
                  as List<String>?,
        opDTHList: freezed == opDTHList
            ? _value._opDTHList
            : opDTHList // ignore: cast_nullable_to_non_nullable
                  as List<String>?,
      ),
    );
  }
}

/// @nodoc

class _$OperatorsStateImpl implements _OperatorsState {
  const _$OperatorsStateImpl({
    required this.isLoading,
    final List<String>? opList,
    final List<String>? opDTHList,
  }) : _opList = opList,
       _opDTHList = opDTHList;

  @override
  final bool isLoading;
  final List<String>? _opList;
  @override
  List<String>? get opList {
    final value = _opList;
    if (value == null) return null;
    if (_opList is EqualUnmodifiableListView) return _opList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<String>? _opDTHList;
  @override
  List<String>? get opDTHList {
    final value = _opDTHList;
    if (value == null) return null;
    if (_opDTHList is EqualUnmodifiableListView) return _opDTHList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'OperatorsState(isLoading: $isLoading, opList: $opList, opDTHList: $opDTHList)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OperatorsStateImpl &&
            (identical(other.isLoading, isLoading) ||
                other.isLoading == isLoading) &&
            const DeepCollectionEquality().equals(other._opList, _opList) &&
            const DeepCollectionEquality().equals(
              other._opDTHList,
              _opDTHList,
            ));
  }

  @override
  int get hashCode => Object.hash(
    runtimeType,
    isLoading,
    const DeepCollectionEquality().hash(_opList),
    const DeepCollectionEquality().hash(_opDTHList),
  );

  /// Create a copy of OperatorsState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$OperatorsStateImplCopyWith<_$OperatorsStateImpl> get copyWith =>
      __$$OperatorsStateImplCopyWithImpl<_$OperatorsStateImpl>(
        this,
        _$identity,
      );
}

abstract class _OperatorsState implements OperatorsState {
  const factory _OperatorsState({
    required final bool isLoading,
    final List<String>? opList,
    final List<String>? opDTHList,
  }) = _$OperatorsStateImpl;

  @override
  bool get isLoading;
  @override
  List<String>? get opList;
  @override
  List<String>? get opDTHList;

  /// Create a copy of OperatorsState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$OperatorsStateImplCopyWith<_$OperatorsStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
